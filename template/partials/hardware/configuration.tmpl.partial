<p>
  The following excerpt from the <a class="xref" href="~/articles/hardware/{{{oe.hardwareDirectory}}}/{{{workflowLocation}}}.html">{{{hardware}}} example workflow</a> demonstrates how to create an ONIX acquisition context using <a class="xref" href="~/api/OpenEphys.Onix1.CreateContext.html">CreateContext</a>, configures a breakout board using <a class="xref" href="~/api/OpenEphys.Onix1.{{{operator}}}.html">{{{operator}}}</a>, and then starts acquisition using <a class="xref" href="~/api/OpenEphys.Onix1.StartAcquisition.html">StartAcquisition</a>. Here we break down each of these operators. 
</p>

<div class="workflow"> 
  <p><img src="~/workflows/{{{oe.path}}}.bonsai" alt="~/workflows/{{{oe.path}}}.bonsai workflow"></p>
</div>

<h2>CreateContext</h2>

<p>
  The <code>CreateContext</code> operator creates a <a class="xref" href="~/api/OpenEphys.Onix1.ContextTask.html">ContextTask</a> that determines the device
  driver, physical interface type, and host-computer index that the system communicates through. The
  <code>Driver</code> property is set to "riffa", which is the name of the PCIe device used by ONIX. In our case,
  because we are using a single ONIX system, the <code>Index</code> property is set to 0. If a second system is
  used on the same computer, a second <code>CreateContext</code> operator would be required
  and its <code>Index</code> property set to 1.
</p>

<h2>{{{operator}}}</h2>

{{{conceptual}}}

<h3>Timestamp & CsvWriter</h3>

<p>
  The <a class="xref" href="https://bonsai-rx.org/docs/api/Bonsai.Reactive.Timestamp.html">TimeStamp</a> operator generates a sequence of timestamped items from its input sequence. This timestamp is a software timestamp and does not exactly coincide with any clock on the {{{hardware}}}. The <a class="xref" href="https://bonsai-rx.org/docs/api/Bonsai.IO.CsvWriter.html">CsvWriter</a> operator writes <code>Timestamp</code> as well as <code>Clock</code>, <code>BlockReadSize</code>, <code>BlockWriteSize</code> members from <code>ContextTask</code> to a file with the following name format: <code>start-time_&lt;timestamp&gt;.csv</code>. Saving the software timestamp provides a record of when this workflow (and thus data acquisition) started. Saving the aforementioned <code>ContextTask</code> members provides a record of memory-related parameters used for data acquisition. The <code>TimeStamp</code> operator generates a sequence of timestamped items from its input sequence. This is accomplished in the {{{hardware}}} example workflow by changing the following properties from their default values. The <code>CsvWriter</code> operator writes <code>Timestamp</code> as well as <code>AcquisitionClockHz</code>, <code>BlockReadSize</code>, <code>BlockWriteSize</code> members from <code>ContextTask</code> to a file with the following name format: <code>start-time_&lt;timestamp&gt;.csv</code>.
</p>

<h2>StartAcquisition</h2>

<p>
  The <code>StartAcquisition</code> operator begins acquisition after the hardware has been
  configured. In the {{{hardware}}} example workflow, we are going to be capturing data from the {{{hardware}}} only, so the
  rate of data being produced by the hardware will be relatively modest (~{{{dataRate}}} MB/s) and dominated by
  the analog input. The <code>StartAcquisition</code>'s <code>BlockReadSize</code> property is set to {{{blockReadSize}}} bytes. This means that the data reading
  thread will block until {{{blockReadSize}}} bytes of data have been produced by the hardware. At {{{dataRate}}} MB/s the
  hardware will produce {{{blockReadSize}}} bytes every ~{{{timeUntilFullBuffer}}}. This is a hard bound on the latency
  of the system. If lower latencies were required, the hardware would need to produce data more
  quickly or the <code>BlockReadSize</code> would need to be reduced. The <code>StartAcquisition</code>'s <code>BlockWriteSize</code> property is set to 2048.
  bytes. This determines the amount of memory that is preallocated for temporarily holding data before
  it is sent to hardware. It is less critical to performance unless the rate that data be written to
  the hardware is comparable to the rate that the hardware produces data which is not a common scenario.
</p>

<div class="NOTE alert alert-info">
  <h5>NOTE</h5>
  <p>To learn about the hardware configuration motif that is present in every workflow involving Onix hardware, visit the <a class="xref" href="~/articles/getting-started/initialize-oni-context.html">Configuration Chain Tutorial</a>.</p>
</div>

<div class="NOTE alert alert-info">
  <h5>NOTE</h5>
  <p>For an overview of the devices on the {{{hardware}}} that can be configured through the <a class="xref" href="~/api/OpenEphys.Onix1.{{{operator}}}.html">{{{operator}}}</a> operator, visit the <a class="xref" href="~/articles/hardware/{{{oe.hardwareDirectory}}}/overview.html">{{{hardware}}} Overview</a>.</p>
</div>

{{#videoCaption}}
  <h2>Editing Operator Properties</h2>
  <p>
    The behavior of an operator is altered by editing its properties. To examine and edit properties, click on the node to
    select it, and view the Properties pane that appears immediately right of the workflow editor. Expanding the members of the
    Properties pane provides configuration access to each of the devices within the {{{hardware}}} which are all briefly described in the <a class="xref" href="~/articles/hardware/{{{oe.hardwareDirectory}}}/overview.html">{{{hardware}}} Overview</a>. For example, this is how the {{{configureOperator}}} 
    properties were edited for the {{{hardware}}} example workflow:
  </p>
  <figure>
    <video width="100%" loop="true" controls="true"><source src="~/images/{{{oe.path}}}.mp4" type="video/mp4"/></video>   
    <figcaption>
      {{{videoCaption}}} It's not necessary to repeat those steps if the {{{hardware}}} configuration workflow is copied-and-pasted into your workflow from either here or the {{{hardware}}} example workflow</a>.
    </figcaption>
  </figure>
{{/videoCaption}}